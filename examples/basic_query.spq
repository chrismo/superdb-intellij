-- Basic SuperSQL Query Example
-- This file demonstrates various SuperSQL features

-- Constant declaration
const MAX_RESULTS = 100
const MIN_SCORE = 0.5

-- Function declaration
fn double(x): x * 2
fn is_high_priority(score): score >= 0.8

-- Type declaration
type UserEvent = {
    user_id: int64,
    event_type: string,
    timestamp: time,
    metadata: |{string: string}|
}

-- Simple SELECT query
SELECT
    user_id,
    event_type,
    count(*) AS event_count
FROM 'https://data.example.com/events.json'
WHERE timestamp >= 2024-01-01T00:00:00Z
GROUP BY user_id, event_type
HAVING event_count > 10
ORDER BY event_count DESC
LIMIT MAX_RESULTS

-- Pipe-based query
FROM data.log
| WHERE level == "error" OR level == "warning"
| sort -r timestamp
| head 50
| put severity := CASE
    WHEN level == "error" THEN "high"
    WHEN level == "warning" THEN "medium"
    ELSE "low"
  END
| SELECT timestamp, message, severity

-- Fork operation for parallel processing
FROM events
| fork (
    -- Branch 1: Count by type
    count() by event_type
  ) (
    -- Branch 2: Get unique users
    distinct user_id
  )

-- Switch operation
FROM logs
| switch message (
    case /error/ (
      put category := "error"
    )
    case /warning/ (
      put category := "warning"
    )
    default (
      put category := "info"
    )
  )

-- Aggregation with WHERE clause
summarize
    total := sum(amount),
    avg_amount := avg(amount) where amount > 0,
    user_count := count(distinct user_id)
by region, category
with -limit 1000

-- Search patterns
search /error|exception|fail/
| search 192.168.1.0/24
| search user_*

-- Record literals
{
    name: "John Doe",
    age: 30,
    email: "john@example.com",
    tags: ["admin", "active"],
    metadata: |{"role": "admin", "dept": "engineering"}|
}

-- Array and set operations
[1, 2, 3, ...existing_array]
|[unique, values, here]|

-- Type casting
SELECT
    user_id::string,
    score::float64,
    CAST(timestamp AS date)
FROM users

-- Special literals
SELECT
    192.168.1.1 AS ipv4_addr,
    ::1 AS ipv6_local,
    10.0.0.0/8 AS network,
    1.5h AS duration_val,
    2024-01-15T10:30:00Z AS timestamp_val,
    0x1a2b3c AS bytes_val,
    true AS bool_val,
    null AS null_val,
    NaN AS nan_val,
    +Inf AS pos_inf
FROM dual

-- Lambda expressions
fn transform(items):
    items | put x := lambda y: y * 2

-- Common table expressions (WITH clause)
WITH
    active_users AS (
        SELECT user_id, name
        FROM users
        WHERE status == "active"
    ),
    user_orders AS (
        SELECT user_id, sum(amount) AS total
        FROM orders
        GROUP BY user_id
    )
SELECT
    u.name,
    o.total
FROM active_users u
LEFT JOIN user_orders o ON u.user_id == o.user_id
ORDER BY o.total DESC
